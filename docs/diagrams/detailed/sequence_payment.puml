@startuml

title Séquence Détaillée : Paiement de Loyer avec Blockchain

autonumber
skinparam sequenceMessageAlign center

actor "Locataire" as Tenant
participant "Frontend\nReact" as UI
participant "MetaMask" as MM
participant "PaymentController" as Ctrl
participant "Payment Model" as PModel
participant "Contract Model" as CModel
participant "BlockchainService" as BC
database "PostgreSQL" as DB
participant "Web3" as Web3
participant "Ganache\n(Blockchain)" as Chain
participant "PaymentManager.sol" as SC

== Phase 1 : Consultation des Paiements Dus ==

Tenant -> UI: Accéder à la page "Paiements"
activate UI

UI -> Ctrl: GET /api/payments?userId={tenantId}&status=pending
activate Ctrl

Ctrl -> PModel: findAll({\nwhere: {status: 'pending'},\ninclude: [{model: Contract, where: {tenantId}}]})
activate PModel
PModel -> DB: SELECT payments.*, contracts.*\nFROM payments\nJOIN contracts ON payments.contract_id = contracts.id\nWHERE payments.status = 'pending'\nAND contracts.tenant_id = ?
activate DB
DB --> PModel: Liste des paiements dus
deactivate DB
PModel --> Ctrl: Payments[] with Contract info
deactivate PModel

Ctrl --> UI: 200 OK\n{payments: [{id, amount, dueDate, contract: {...}}]}
deactivate Ctrl

UI -> UI: Calculer jours de retard pour chaque paiement
UI -> UI: Afficher badge "En retard" si dueDate < today

UI --> Tenant: Liste des paiements avec:\n- Montant\n- Date d'échéance\n- Pénalité estimée\n- Bouton "Payer"
deactivate UI

== Phase 2 : Initialisation du Paiement ==

Tenant -> UI: Cliquer "Payer" sur paiement #{paymentId}
activate UI

UI -> UI: Vérifier si MetaMask est installé

alt MetaMask non installé
    UI --> Tenant: Erreur: "Installez MetaMask pour payer"
    deactivate UI
    
else MetaMask installé
    UI -> MM: ethereum.request({method: 'eth_requestAccounts'})
    activate MM
    MM --> Tenant: Popup: "Connecter votre wallet?"
    Tenant -> MM: Approuver connexion
    MM --> UI: [accountAddress]
    deactivate MM
    
    UI -> UI: Vérifier accountAddress == contract.tenant.blockchainAddress
    
    UI -> Ctrl: POST /api/payments/:id/pay\nHeaders: {Authorization: Bearer {token}}
    activate Ctrl
    
    Ctrl -> PModel: findByPk(paymentId, {include: Contract})
    activate PModel
    PModel -> DB: SELECT payments.*, contracts.*\nWHERE payments.id = ?
    activate DB
    DB --> PModel: Payment + Contract data
    deactivate DB
    PModel --> Ctrl: Payment object
    deactivate PModel
    
    Ctrl -> Ctrl: Vérifier payment.status == 'pending'
    Ctrl -> Ctrl: Vérifier user == contract.tenant
    
    Ctrl -> BC: getContractInstance(PaymentManagerABI, contract.paymentManagerAddress)
    activate BC
    BC -> Web3: new Contract(abi, address)
    activate Web3
    Web3 --> BC: PaymentManager instance
    deactivate Web3
    deactivate BC
    
    == Interaction avec Smart Contract ==
    
    Ctrl -> BC: paymentManager.methods.getPaymentStatus(payment.paymentIndex).call()
    activate BC
    BC -> Web3: call()
    activate Web3
    Web3 -> Chain: eth_call getPaymentStatus(paymentIndex)
    activate Chain
    Chain -> SC: getPaymentStatus(paymentIndex)
    activate SC
    SC --> Chain: PaymentInfo{dueDate, amount, isPaid, penalty, paidDate}
    deactivate SC
    deactivate Chain
    Web3 --> BC: PaymentInfo
    deactivate Web3
    deactivate BC
    
    Ctrl -> Ctrl: Calculer montant total = amount + penalty estimée
    
    Ctrl --> UI: 200 OK\n{paymentInfo: {amount, penalty, totalAmount}}
    deactivate Ctrl
    
    == Confirmation MetaMask ==
    
    UI -> MM: ethereum.request({\nmethod: 'eth_sendTransaction',\nparams: [{\nfrom: tenantAddress,\nto: paymentManagerAddress,\nvalue: Web3.utils.toHex(totalAmountInWei),\ndata: paymentManager.methods.makePayment(paymentIndex).encodeABI()\n}]\n})
    activate MM
    
    MM --> Tenant: Popup MetaMask:\n"Confirmer le paiement"\nMontant: {totalAmount} ETH\nGas: ~0.001 ETH
    
    Tenant -> MM: Confirmer transaction
    
    MM -> Chain: Envoyer transaction signée
    activate Chain
    
    Chain -> SC: makePayment(paymentIndex)\nmsg.value = totalAmountInWei
    activate SC
    
    SC -> SC: require(!payments[paymentIndex].isPaid)
    SC -> SC: require(block.timestamp >= 0)
    
    SC -> SC: calculatePenalty(paymentIndex)
    note right
      uint256 daysLate = (block.timestamp - dueDate) / 86400
      if (daysLate > gracePeriodDays) {
        penalty = (daysLate - gracePeriodDays) 
                  * penaltyRate * amount / 100
      }
    end note
    
    SC -> SC: totalDue = amount + penalty
    SC -> SC: require(msg.value >= totalDue)
    
    SC -> SC: payments[paymentIndex].isPaid = true
    SC -> SC: payments[paymentIndex].paidDate = block.timestamp
    SC -> SC: payments[paymentIndex].penalty = penalty
    
    SC -> SC: emit PaymentMade(paymentIndex, amount, penalty)
    
    alt Trop-perçu (msg.value > totalDue)
        SC -> SC: Rembourser excess = msg.value - totalDue
        SC -> Tenant: transfer(excess)
    end
    
    SC --> Chain: Transaction réussie
    deactivate SC
    
    Chain --> MM: Transaction hash + receipt
    deactivate Chain
    
    MM --> UI: {transactionHash, status: 'success'}
    deactivate MM
    
    == Mise à Jour Base de Données ==
    
    UI -> Ctrl: PUT /api/payments/:id/confirm\n{transactionHash}
    activate Ctrl
    
    Ctrl -> BC: web3.eth.getTransactionReceipt(transactionHash)
    activate BC
    BC -> Chain: eth_getTransactionReceipt
    activate Chain
    Chain --> BC: Receipt{status, blockNumber, gasUsed, logs}
    deactivate Chain
    BC --> Ctrl: Transaction receipt
    deactivate BC
    
    Ctrl -> Ctrl: Vérifier receipt.status == 'success'
    
    Ctrl -> BC: Extraire penalty des logs d'événement
    activate BC
    BC -> BC: Décoder event PaymentMade
    BC --> Ctrl: {paymentId, amount, penalty}
    deactivate BC
    
    Ctrl -> PModel: update(paymentId, {\nstatus: 'paid',\npaidDate: now,\ntransactionHash,\npenalty})
    activate PModel
    PModel -> DB: UPDATE payments\nSET status = 'paid',\npaid_date = NOW(),\ntransaction_hash = ?,\npenalty = ?\nWHERE id = ?
    activate DB
    DB --> PModel: Paiement mis à jour
    deactivate DB
    PModel --> Ctrl: Updated payment
    deactivate PModel
    
    Ctrl --> UI: 200 OK\n{payment: {status: 'paid', transactionHash, penalty}}
    deactivate Ctrl
    
    UI -> UI: Rafraîchir liste des paiements
    UI --> Tenant: ✓ Paiement confirmé!\nTransaction: {shortHash}\nPénalité: {penalty} ETH
    deactivate UI
    
    note right of Tenant
      Le paiement est maintenant
      enregistré de manière immuable
      sur la blockchain.
      
      Le propriétaire peut retirer
      les fonds à tout moment.
    end note
end

== Phase 3 : Écoute d'Événements (Background) ==

Chain -> BC: Event: PaymentMade(paymentId, amount, penalty)
activate BC
BC -> Ctrl: Webhook/Listener callback
activate Ctrl
Ctrl -> Ctrl: Log l'événement
Ctrl -> UI: WebSocket notification (optionnel)
activate UI
UI --> Tenant: Notification temps réel:\n"Paiement traité avec succès"
deactivate UI
deactivate Ctrl
deactivate BC

@enduml
